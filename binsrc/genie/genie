#! /usr/bin/python

import argparse
import configparser
import fcntl
import os
import subprocess
import sys
import time

import nsenter
import psutil

### Global variables
verbose = False
login = None
config = None

lockfile_fp = None

### Helper functions

def bottle_init_lock():
    """Lock the bottle init process to one instance only."""
    global lockfile_fp

    lockfile_fp = open ('/run/genie.init.lock', 'a')

    try:
        fcntl.lockf(lockfile_fp, fcntl.LOCK_EX | fcntl.LOCK_NB)
        lockfile_fp.seek(0)
        lockfile_fp.truncate()
        lockfile_fp.write(str(os.getpid()))
        lockfile_fp.flush()
        running = False
    except IOError:
        with open('/run/genie.init.lock', 'r') as fp:
            running = fp.read()

    return running

def bottle_init_unlock():
    """Unlock the bottle init process."""
    fcntl.lockf (lockfile_fp, fcntl.LOCK_UN)
    lockfile_fp.close ()

    os.remove ("/run/genie.init.lock")


def find_systemd():
    """Find the running systemd process and return its pid."""
    for proc in psutil.process_iter():
        if "systemd" in proc.name():
            return proc.pid

    return 0

def get_systemd_state(sdp):
    """Get the systemd state, whether we are within or without the bottle."""

    if sdp == 0:
        return "offline"

    with nsenter.Namespace (sdp, 'pid'):
        sc = subprocess.run (["systemctl", "is-system-running"], capture_output=True, text=True)
        return sc.stdout.rstrip()

def load_configuration():
    """Load the configuration from the config file ('/etc/genie.ini')."""
    global config

    config = configparser.ConfigParser()
    config.read ('/etc/genie.ini')

def parse_command_line():
    """Create the command-line option parser and parse arguments."""
    parser = argparse.ArgumentParser (
        description = "Handles transitions to the \"bottle\" namespace for systemd under WSL.",
        epilog = "For more information, see https://github.com/arkane-systems/genie/")

    # Version command
    parser.add_argument ('-V', '--version', action='version', version='%(prog)s 2.0')

    # Verbose option
    parser.add_argument ('-v', '--verbose', action='store_true', help="display verbose progress messages")

    # Commands
    group = parser.add_mutually_exclusive_group (required=True)

    group.add_argument('-i', '--initialize', action='store_true', help='initialize the bottle (if necessary) only')
    group.add_argument('-s', '--shell', action='store_true', help='initialize the bottle (if necessary), and run a shell in it')
    group.add_argument('-l', '--login', action='store_true', help='initialize the bottle (if necessary), and open a logon prompt in it')
    group.add_argument('-c', '--command', help='initialize the bottle (if necessary), and run the specified command in it', nargs=argparse.REMAINDER)
    group.add_argument('-u', '--shutdown', action='store_true', help='shut down systemd and exit the bottle')
    group.add_argument('-r', '--is-running', action='store_true', help='check whether systemd is running in genie, or not')
    group.add_argument('-b', '--is-in-bottle', action='store_true', help='check whether currently executing within the bottle, or not')

    return parser.parse_args()

def prelaunch_checks():
    """Check that we are on the correct platform, and as the correct user."""

    # Is this Linux?
    if not sys.platform.startswith('linux'):
        sys.exit("genie: not executing on the Linux platform - how did we get here?")

    # Is this WSL 1?
    root_type = list(filter(lambda x: x.mountpoint == '/', psutil.disk_partitions()))[0].fstype
    if root_type == 'lxfs' or root_type == 'wslfs':
        sys.exit("genie: systemd is not supported under WSL 1.")

    # Is this WSL 2?
    if not os.path.exists('/run/WSL'):
        if not 'microsoft' in os.uname():
            sys.exit("genie: not executing under WSL 2 - how did we get here?")

    # Are we effectively root?
    if os.geteuid() != 0:
        sys.exit("genie: must execute as root - has the setuid bit gone astray?")

def pre_systemd_action_checks(sdp):
    """Things to check before performing a systemd-requiring action."""

    if sdp == 0:
        # no bottle exists; this means we should recurse and start one
        initcommand = [ "genie", "-i" ]

        if verbose:
            initcommand.append ("-v")

        init = subprocess.run (initcommand)

        # continue when subprocess done
        if init.returncode != 0:
            sys.exit (f"could not initialise bottle, exit code = {init.returncode}")

        # Refresh systemd pid
        sdp = find_systemd()

    state = get_systemd_state(sdp)

    if 'stopping' in state:
        sys.exit ("genie: systemd is shutting down, cannot proceed")

    if 'initializing' in state or 'starting' in state:
        # wait for it
        # TODO
        return

    if 'degraded' in state:
        print ('genie: WARNING: systemd is in degraded state, issues may occur!')

    if not ('running' in state or 'degraded' in state):
        sys.exit ("genie: systemd in unsupported state '" + state + "'; cannot proceed")

#             // If bottle is starting up, wait for it.
#             if (state.BottleStartingUp)
#             {
#                 Console.Write ("genie: bottle is starting in another session, please wait");

#                 do
#                 {
#                     Thread.Sleep (1000);
#                     Console.Write (".");

#                     state = new BottleStatus (verbose);
#                 } while (!state.BottleExistsInContext);

#                 Console.WriteLine();
#             }

### Commands

def do_initialize():
    """Initialize the genie bottle."""
    if verbose:
        print ("genie: starting bottle")

    # Secure the bottle init lock
    running = bottle_init_lock()
    if running:
      # TODO: make wait instead
      sys.exit (f"genie: already initializing, pid={running}")

    sdp = find_systemd()

    if sdp != 0:
        sys.exit ("genie: bottle is already established (systemd running)")

    # TODO: super-minimal for now

    # Define systemd startup chain.
    startupChain = ["daemonize", "/usr/bin/unshare", "-fp", "--propagation", "shared", "--mount-proc", "--"]

    # Update startup chain with systemd command.
    startupChain.append ("systemd")

    # Run systemd in a container
    if verbose:
        print ("genie: starting systemd with command line: ")
        print (' '.join(startupChain))

    # Daemonize requires real UID root as well as effective UID root
    suid = os.getuid()
    os.setuid(0)

    subprocess.run (startupChain)

    os.setuid(suid)

    # Wait for systemd to be up (polling, sigh.)
    sdp = 0
    print ("Waiting for systemd...", end="", flush=True)

    while sdp == 0:
        time.sleep (0.5)
        sdp = find_systemd()

        print (".", end="", flush=True)

    # Now that systemd exists, write out its (external) pid.
    # We do not need to store the inside-bottle pid anywhere for obvious reasons.
    with open ('/run/genie.systemd.pid', 'w') as pidfile:
      print (sdp, file=pidfile)

    # Wait for systemd to be in running state.
    state = 'initializing'
    timeout = config.getint ('genie', 'systemd-timeout', fallback=240))

    while (not 'running' in state) and timeout > 0:
        time.sleep (1)
        state = get_systemd_state (sdp)

        print ("!", end="", flush=True)

        timeout -= 1

    print ("")

    # Unlock the init lock
    bottle_init_unlock()

## Run inside bottle.
def do_shell():
    """Start a shell inside the bottle, initializing it if necessary."""

    if verbose:
        print ("genie: starting shell")

    pre_systemd_action_checks(find_systemd())

    sdp = find_systemd()

    if sdp == 1:
        # we're already inside the bottle
        sys.exit("genie: already inside the bottle; cannot proceed")

    # At this point, we should be outside a bottle, one way or another.
    # Get the bottle namespace
    with nsenter.Namespace (sdp, 'pid'):
        subprocess.run( "machinectl shell -q " + login + "@.host", shell=True)

def do_login():
    """Start a login prompt inside the bottle, initializing it if necessary."""

    if verbose:
        print ("genie: starting login prompt")

    pre_systemd_action_checks(find_systemd())

    sdp = find_systemd()

    if sdp == 1:
        # we're already inside the bottle
        sys.exit("genie: already inside the bottle; cannot proceed")

    # At this point, we should be outside a bottle, one way or another.
    # Get the bottle namespace
    with nsenter.Namespace (sdp, 'pid'):
        subprocess.run ("machinectl login .host", shell=True)

def do_command(commandline):
    """Run a command in a user session inside the bottle, initializing it if necessary."""

    if verbose:
        print ("genie: running command " + ' '.join(commandline))

    sdp = find_systemd()

    if sdp == 1:
        # we're already inside the bottle
        ic = subprocess.run (commandline)
        return ic.returncode

    pre_systemd_action_checks(sdp)

    sdp = find_systemd()

    command = ["machinectl", "shell", "-q", login + "@.host"] + commandline

    with nsenter.Namespace (sdp, 'pid'):
        # TODO: fix with runinwsl
        subprocess.run (' '.join(command), shell=True)

#         #region Run inside bottle

#             var commandPrefix = new string[] {"machinectl", "shell", "-q", $"{realUserName}@.host", Config.GetPrefixedPath ("lib/genie/runinwsl"),
#                     Environment.CurrentDirectory };

#             var command = commandPrefix.Concat(commandLine);

#             Helpers.ChainInside (systemdPid,
#                 command.ToArray(),
#                 "running command failed; machinectl shell");
#         }

#         #endregion

def do_shutdown():
    print ('todo: shutdown command')

def do_is_running():
    print ('todo: is_running command')
    print (config['genie']['secure-path'])

def do_is_in_bottle():
    print ('todo: is_in_bottle command')

### Entrypoint
def entrypoint():
    """Entrypoint of the application."""
    global verbose
    global login

    prelaunch_checks()
    load_configuration()
    arguments = parse_command_line()

    ## Set globals
    verbose = arguments.verbose
    login = os.environ["LOGNAME"]

    ## Decide what to do.
    if arguments.initialize:
        do_initialize()
    elif arguments.shell:
        do_shell()
    elif arguments.login:
        do_login()
    elif not arguments.command is None:
        do_command(arguments.command)
    elif arguments.shutdown:
        do_shutdown()
    elif arguments.is_running:
        do_is_running()
    elif arguments.is_in_bottle:
        do_is_in_bottle()
    else:
        sys.exit ("genie: impossible argument - how did we get here?")

entrypoint()

### End

# old code

# namespace ArkaneSystems.WindowsSubsystemForLinux.Genie
# {
#     public static class Program
#     {
#         #region Helper methods

#         #region AppArmor

#         private static void ConfigureAppArmorNamespace (ref string[] startupChain, bool verbose)
#         {
#             // Check whether AppArmor is available in the kernel.
#             if (Directory.Exists("/sys/module/apparmor"))
#             {
#                 // If the AppArmor filesystem is not mounted, mount it.
#                 if (!Directory.Exists("/sys/kernel/security/apparmor"))
#                 {
#                     // Mount AppArmor filesystem.
#                     if (!MountHelpers.Mount ("securityfs", "/sys/kernel/security", "securityfs"))
#                     {
#                         Console.WriteLine ("genie: could not mount AppArmor filesystem; attempting to continue without AppArmor namespace");
#                         return;
#                     }
#                 }

#                 // Create AppArmor namespace for genie bottle.
#                 string nsName = $"genie-{Helpers.WslDistroName}";

#                 if (verbose)
#                    Console.WriteLine ($"genie: creating AppArmor namespace {nsName}");

#                 if (!Directory.Exists("/sys/kernel/security/apparmor/policy/namespaces"))
#                 {
#                     Console.WriteLine ("genie: could not find AppArmor filesystem; attempting to continue without AppArmor namespace");
#                     return;
#                 }

#                 Directory.CreateDirectory ($"/sys/kernel/security/apparmor/policy/namespaces/{nsName}");

#                 // Update startup chain with aa-exec command.
#                 startupChain = startupChain.Concat(new string[] {"aa-exec", "-n", $"{nsName}", "-p", "unconfined", "--"}).ToArray();
#             }
#             else
#             {
#                 Console.WriteLine ("genie: AppArmor not available in kernel; attempting to continue without AppArmor namespace");
#             }
#         }

#         // Now we have exited the bottle, clean up the AppArmor namespace.
#         private static void UnconfigureAppArmorNamespace (bool verbose)
#         {
#             string nsName = $"genie-{Helpers.WslDistroName}";

#             if (verbose)
#                 Console.WriteLine ($"genie: deleting AppArmor namespace {nsName}");

#             if (Directory.Exists($"/sys/kernel/security/apparmor/policy/namespaces/{nsName}"))
#             {
#                 try
#                 {
#                     Directory.Delete($"/sys/kernel/security/apparmor/policy/namespaces/{nsName}");
#                 }
#                 catch (Exception ex)
#                 {
#                     Console.WriteLine ($"genie: could not delete AppArmor namespace; {ex.Message}");
#                 }
#             }
#             else
#                 Console.WriteLine ("genie: no AppArmor namespace to delete");
#         }

#         #endregion AppArmor

#         #region Binfmts

#         // Unmount the binfmts fs.
#         private static void UnmountBinfmts (bool verbose)
#         {
#             if (Directory.Exists("/proc/sys/fs/binfmt_misc"))
#             {
#                 if (verbose)
#                     Console.WriteLine ("genie: unmounting binfmt_misc filesystem before proceeding");

#                 if (!MountHelpers.UnMount ("/proc/sys/fs/binfmt_misc"))
#                 {
#                     Console.WriteLine ("genie: failed to unmount binfmt_misc filesystem; attempting to continue");
#                 }
#             }
#             else
#             {
#                 if (verbose)
#                     Console.WriteLine ("genie: no binfmt_misc filesystem present");
#             }
#         }

#         // Having unmounted the binfmts fs before starting systemd, we remount it now as
#         // a courtesy. But remember, genie is not guaranteed to be idempotent, so don't
#         // rely on this, for the love of Thompson and Ritchie!
#         private static void RemountBinfmts (bool verbose)
#         {
#             if (!Directory.Exists("/proc/sys/fs/binfmt_misc"))
#             {
#                 if (verbose)
#                     Console.WriteLine ("genie: remounting binfmt_misc filesystem as a courtesy");

#                 if (!MountHelpers.Mount("binfmt_misc", "/proc/sys/fs/binfmt_misc", FsType.BinaryFormats))
#                 {
#                     Console.WriteLine ("genie: failed to remount binfmt_misc filesystem; attempting to continue");
#                 }
#             }
#         }

#         // Set up secure path, saving original if specified.
#         private static void SetUpSecurePath()
#         {
#             string originalPath;

#             if (Config.ClonePath)
#                 originalPath = Environment.GetEnvironmentVariable("PATH");
#             else
#                 // TODO: Should reference system drive by letter
#                 originalPath = @"/mnt/c/Windows/System32";

#             Environment.SetEnvironmentVariable ("PATH", Config.SecurePath);

#             // Create the path file.
#             File.WriteAllText("/run/genie.path", originalPath);
#         }

#         // Stash original environment (specified variables only).
#         private static void StashEnvironment()
#         {
#             string[] clonedVariables;

#             clonedVariables = GenieConfig.DefaultVariables
#                 .Union (from DictionaryEntry de in Environment.GetEnvironmentVariables()
#                         where Config.CloneEnv.Contains (de.Key)
#                         select $"{de.Key}={de.Value}")
#                 .ToArray();

#             // Create the env file.
#             File.WriteAllLines("/run/genie.env", clonedVariables);
#         }

#         #endregion Helper methods

#         #region Bottle startup and shutdown

#         // Do the work of initializing the bottle.
#         public static void StartBottle (bool verbose)
#         {
#             SetUpSecurePath();
#             StashEnvironment();

#             // Check and warn if not multi-user.target
#             if (Config.TargetWarning)
#             {
#                 Helpers.RunAndWait ("sh", new string[] { Config.GetPrefixedPath ("lib/genie/check-default-target.sh") });
#             }

#             // Now that the WSL hostname can be set via .wslconfig, we're going to make changing
#             // it automatically in genie an option, enable/disable in genie.ini. Defaults to on
#             // for backwards compatibility and because turning off when using bridged networking is
#             // a Bad Idea.
#             if (Config.UpdateHostname)
#                 Helpers.UpdateHostname (Config.HostnameSuffix, verbose);

#             // If configured to, create the resolv.conf symlink.
#             if (Config.ResolvedStub)
#                 Helpers.CreateResolvSymlink (verbose);

#             // Unmount the binfmts fs before starting systemd, so systemd can mount it
#             // again with all the trimmings.
#             UnmountBinfmts (verbose);

#             // Define systemd startup chain - command string to pass to daemonize
#             string [] startupChain = new string[] {Config.PathToUnshare, "-fp", "--propagation", "shared", "--mount-proc", "--"};

#             // If requested, configure AppArmor namespace.
#             if (Config.AppArmorNamespace)
#                 ConfigureAppArmorNamespace (ref startupChain, verbose);

#             // Now that systemd exists, write out its (external) PID.
#             // We do not need to store the inside-bottle PID anywhere for obvious reasons.
#             // Create the path file.
#             File.WriteAllText("/run/genie.systemd.pid", systemdPid.ToString());

#         // Do the work of shutting down the bottle.
#         public static void StopBottle (bool verbose)
#         {
#             FlagFiles.ShutdownFile = true;
#             FlagFiles.RunFile = false;

#             if (verbose)
#                 Console.WriteLine ("genie: running systemctl poweroff within bottle");

#             var systemdPid = Helpers.GetSystemdPid();
#             var sd = Process.GetProcessById (systemdPid);

#             Helpers.ChainInside (systemdPid,
#                 new string[] {"systemctl", "poweroff"},
#                 "running command failed; nsenter systemctl poweroff");

#             // Wait for systemd to exit.
#             Console.Write ("Waiting for systemd exit...");

#             int timeout = Config.SystemdStartupTimeout;

#             while (!sd.WaitForExit(1000))
#             {
#                 Console.Write (".");
#                 timeout--;

#                 if (timeout < 0)
#                 {
#                     Console.WriteLine("\n\nTimed out waiting for systemd to exit.\nThis may indicate a systemd configuration error.\nAttempting to continue.");
#                     break;
#                 }
#             }

#             Console.WriteLine();

#             // We reverse the processes we performed to pre-startup the bottle as the post-shutdown, in reverse order.
#             if (Config.AppArmorNamespace)
#                 UnconfigureAppArmorNamespace (verbose);

#             RemountBinfmts (verbose);

#             if (Config.ResolvedStub)
#                 Helpers.RemoveResolvSymlink (verbose);

#             if (Config.UpdateHostname)
#             {
#                 Thread.Sleep (500);
#                 Helpers.DropHostname (verbose);
#             }

#             FlagFiles.ShutdownFile = false;
#         }

#         #endregion Bottle startup and shutdown

#         // // Initialize the bottle (if necessary) only
#         public static int InitializeHandler (bool verbose)
#         {
#             // Get the bottle state.
#             var state = new BottleStatus (verbose);

#             // If a bottle exists, we have succeeded already. Exit and report success.
#             if (state.Status != Status.NoBottlePresent)
#             {
#                 if (verbose)
#                     Console.WriteLine ("genie: bottle already exists (no need to initialize).");

#                 return 0;
#             }

#             // Daemonize expects real uid root as well as effective uid root.
#             using (var r = new RootPrivilege())
#             {
#                 // Init the bottle.
#                 StartBottle(verbose);
#             }

#             return 0;
#         }

#         // Start a login prompt inside the bottle, initializing it if necessary.
#         public static int LoginHandler (bool verbose)
#         {
#             // Get the bottle state.
#             var state = new BottleStatus (verbose);

#             // If inside bottle, cannot start shell.
#             if (state.StartedWithinBottle)
#             {
#                 Console.WriteLine ("genie: already inside the bottle; cannot start login prompt!");
#                 return EINVAL;
#             }

#             // If shutting down, display error and exit.
#             if (state.BottleClosingDown)
#             {
#                 Console.WriteLine ("genie: bottle is stopping, cannot start login prompt!");
#                 return ECANCELED;
#             }

#             // If bottle does not exist, initialize it.
#             if (!state.BottleExistsInContext && !state.BottleStartingUp)
#             {
#                 // Daemonize expects real uid root as well as effective uid root.
#                 using (var r = new RootPrivilege())
#                 {
#                     // Init the bottle.
#                     StartBottle(verbose);
#                 }
#             }

#             // If bottle is starting up, wait for it.
#             if (state.BottleStartingUp)
#             {
#                 Console.Write ("genie: bottle is starting in another session, please wait");

#                 do
#                 {
#                     Thread.Sleep (1000);
#                     Console.Write (".");

#                     state = new BottleStatus (verbose);
#                 } while (!state.BottleExistsInContext);

#                 Console.WriteLine();
#             }

#             if (state.BottleError)
#             {
#                 Console.WriteLine ("* WARNING: Bottled systemd is not in running state; errors may occur");
#             }

#             using (var r = new RootPrivilege())
#             {
#                 // At this point, we should be outside an existing bottle, one way or another.

#                 // It shouldn't matter whether we have setuid here, since we start the shell with
#                 // a login prompt, which reassigns uid appropriately as login(1).
#                 StartLogin (verbose, Helpers.GetSystemdPid());
#             }

#             return 0;
#         }

#         // Run a command inside the bottle, initializing it if necessary.
#         public static int ExecHandler (bool verbose, IEnumerable<string> command)
#         {
#             // Get the bottle state.
#             var state = new BottleStatus (verbose);

#             // If inside bottle, just execute the command.
#             if (state.StartedWithinBottle)
#                 return Helpers.RunAndWait (command.First(), command.Skip(1).ToArray());

#             // If shutting down, display error and exit.
#             if (state.BottleClosingDown)
#             {
#                 Console.WriteLine ("genie: bottle is stopping, cannot run command!");
#                 return ECANCELED;
#             }

#             // If bottle does not exist, initialize it.
#             if (!state.BottleExistsInContext && !state.BottleStartingUp)
#             {
#                 // Daemonize expects real uid root as well as effective uid root.
#                 using (var r = new RootPrivilege())
#                 {
#                     // Init the bottle.
#                     StartBottle(verbose);
#                 }
#             }

#             // If bottle is starting up, wait for it.
#             if (state.BottleStartingUp)
#             {
#                 Console.Write ("genie: bottle is starting in another session, please wait");

#                 do
#                 {
#                     Thread.Sleep (1000);
#                     Console.Write (".");

#                     state = new BottleStatus (verbose);
#                 } while (!state.BottleExistsInContext);

#                 Console.WriteLine();
#             }

#             if (state.BottleError)
#             {
#                 Console.WriteLine ("* WARNING: Bottled systemd is not in running state; errors may occur");
#             }

#             using (var r = new RootPrivilege())
#             {
#                 // At this point, we should be inside an existing bottle, one way or another.

#                 RunCommand (verbose, Helpers.GetSystemdPid(), command.ToArray());
#             }

#             return 0;
#         }

#         // Shut down the bottle and clean up.
#         public static int ShutdownHandler (bool verbose)
#         {
#             // Get the bottle state.
#             var state = new BottleStatus (verbose);

#             if (state.Status == Status.NoBottlePresent)
#             {
#                 Console.WriteLine ("genie: no bottle exists.");
#                 return EINVAL;
#             }

#             if (state.StartedWithinBottle)
#             {
#                 Console.WriteLine ("genie: cannot shut down bottle from inside bottle; exiting.");
#                 return EINVAL;
#             }

#             if (state.BottleWillExist || state.BottleClosingDown)
#             {
#                 Console.WriteLine ("genie: bottle in transitional state; please wait until this is complete.");
#             }

#             using (var r = new RootPrivilege())
#             {
#                 StopBottle (verbose);
#             }

#             return 0;
#         }

#         // Check whether systemd has been started by genie, or not.
#         public static int IsRunningHandler (bool verbose)
#         {
#             // Get the bottle state.
#             var state = new BottleStatus (verbose);

#             if (state.BottleExists && !state.BottleError)
#             {
#                 Console.WriteLine ("running");
#                 return 0;
#             }
#             else if (state.BottleWillExist)
#             {
#                 Console.WriteLine ("starting");
#                 return 2;
#             }
#             else if (state.BottleClosingDown)
#             {
#                 Console.WriteLine ("stopping");
#                 return 3;
#             }
#             else if (state.BottleError)
#             {
#                 Console.WriteLine ("running (systemd errors)");
#                 return 4;
#             }

#             Console.WriteLine ("stopped");
#             return 1;
#         }

#         // Check whether currently executing within the genie bottle, or not.
#         public static int IsInsideHandler (bool verbose)
#         {
#             // Get the bottle state.
#             var state = new BottleStatus (verbose);

#             if (state.StartedWithinBottle)
#             {
#                 Console.WriteLine ("inside");
#                 return 0;
#             }
#             else if (!(state.Status == Status.NoBottlePresent))
#             {
#                 Console.WriteLine("outside");
#                 return 1;
#             }

#             Console.WriteLine("no-bottle");
#             return 2;
#         }

#         // Cleanup leftover genie files
#         public static int CleanupHandler (bool verbose)
#         {
#             string[] files = {
#                 "/run/genie.startup",
#                 "/run/genie.shutdown",
#                 "/run/genie.up",
#                 "/run/genie.env",
#                 "/run/genie.path",
#                 "/run/genie.systemd.pid",
#                 "/run/hostname-wsl"
#             };

#             // Get the bottle state.
#             var state = new BottleStatus (verbose);

#             if (state.Status != Status.NoBottlePresent)
#             {
#                 Console.WriteLine ("genie: cannot clean up while bottle exists.");
#                 return EINVAL;
#             }

#             foreach (string s in files)
#             {
#                 if (File.Exists (s))
#                 {
#                     if (verbose)
#                         Console.WriteLine ($"genie: deleting leftover file {s}");

#                     File.Delete (s);
#                 }
#             }

#             return 0;
#         }

#         #endregion Command handlers

#         // Configuration for genie.
#         internal static GenieConfig Config { get; } = new GenieConfig();

#         // User name of the real user running genie.
#         public static string realUserName { get; set;}

#     }
# }
